package IC.Parser;

import IC.AST.*;
import java.util.ArrayList;
import java.util.List;
import IC.LiteralTypes;
import IC.DataTypes;

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

/* ids */
terminal String ID;
terminal String CLASSID;
/* keywords */
terminal EXTENDS, STATIC, VOID, INT, BOOL, STRING, RETURN, IF, ELSE, WHILE, BREAK, CONTINUE;
terminal THIS, NEW, LENGTH, CLASS;
/* literals */
terminal Integer INTEGER;
terminal String STRING_LITERAL;
terminal FALSE, NULL, TRUE;
/* punctuation */
terminal LP, RP, CRP, CLP, SQUARERB, SQUARELB, DOT, SEMCOL, COMMA;
/* operators */
terminal ADD, MINUS, MULT, DIV, MOD, LESSTHAN, LESSTHANEQ, GREATERTHAN, GREATERTHANEQ, EQ;
terminal NOTEQ, AND, OR, NOT, ASSIGN;

nonterminal Program program;
nonterminal List<ICClass> class_list;
nonterminal ICClass       icclass;
nonterminal Method        method;

nonterminal String  extends_opt;
nonterminal List<ASTNode> fields_methods_list;

nonterminal Type type;
nonterminal List<Field> field_collection;
nonterminal List<String>    field_id_list;

nonterminal Type     return_type;

nonterminal Formal   formal;
nonterminal List<Formal> comma_formal_list;
nonterminal List<Formal> formal_list;
nonterminal List<Formal> formal_list_opt;


nonterminal Call call;
nonterminal VirtualCall virtual_call;
nonterminal StaticCall static_call;
nonterminal Expression exp;
nonterminal Location location;
nonterminal ArrayLocation array_location;
nonterminal VariableLocation variable_location;
nonterminal Expression exp_and_dot_op;
nonterminal List<Expression> exp_list;
nonterminal Test_start;
nonterminal empty;
nonterminal List<Expression> exp_list_op;



nonterminal stmt;
nonterminal expr;

nonterminal binop;
nonterminal unop;
nonterminal literal;
nonterminal stmt_lst;
nonterminal stmt_lst_not_empty;

//////////////////////////
// Precedence declarations

//////////////
// The grammar

Test_start ::= program {: :};

call ::= virtual_call:c {: RESULT =c; :}
		| static_call:c {: RESULT =c; :}
		;

static_call ::= CLASSID:class_id DOT ID:id LP exp_list_op:lst RP 
			{: RESULT = new StaticCall(1,class_id,id,lst); :}
			;
			
virtual_call ::= expr:e DOT ID:id LP exp_list_op:lst RP 
			{: RESULT = new VirtualCall(1,e,id,lst);:}
			| ID:id LP exp_list_op:lst RP 
			{: RESULT = new VirtualCall(1,new Literal(-1,LiteralTypes.STRING),id,lst);:}
			;

empty ::=	{: :};		
			
exp_list_op ::= exp_list:lst {: :} | empty {: RESULT = new ArrayList<Expression>(); :};

exp_list ::= expr:e 
			{:  List<Expression> lst = new ArrayList<Expression>();
				lst.add(e);
				RESULT = lst; :}
			| exp_list:lst expr:e 
			{:  lst.add(e);
				RESULT = lst; :}
			;


location ::= variable_location:loc {: RESULT =loc; :}
			| array_location:loc {: RESULT =loc; :}
			;
			
variable_location ::= ID:id {: RESULT = new VariableLocation(1,id); :}
					| expr:e DOT ID:id {: RESULT = new VariableLocation(1,e,id); :}
					;

array_location ::= expr:out_exp SQUARELB expr:in_exp SQUARERB
				{: RESULT = new ArrayLocation(out_exp,in_exp); :}
				;
	
	
	
program ::= class_list:lst
	{: RESULT = new Program(lst); :}
	| empty
	{: RESULT = new Program(new ArrayList<ICClass>()); :}
	;

class_list ::= icclass:c
	{: RESULT = new ArrayList<ICClass>();
	   RESULT.add(c); 
	:}
	| class_list:lst icclass:c
	{: lst.add(c); RESULT = lst; :}
	;

icclass ::= CLASS CLASSID:name extends_opt:superclass CLP fields_methods_list:lst CRP
	{: /* with a given method\field list */
		List<Field> fields = new ArrayList<Field>();
		List<Method> methods = new ArrayList<Method>();
		for(ASTNode item : lst)
		{
			if(item instanceof Field)
				fields.add((Field)item);
			else
				methods.add((Method)item);
		}
		if(superclass == null)
			RESULT = new ICClass( -1, name, fields, methods);
		else
			RESULT = new ICClass(-1, name, superclass, fields, methods);
		
	:}
	| CLASS CLASSID:name extends_opt:superclass CLP CRP
	{:  /* empty class */
		List<Field> fields = new ArrayList<Field>();
		List<Method> methods = new ArrayList<Method>();
		if(superclass == null)
			RESULT = new ICClass( -1, name, fields, methods);
		else
			RESULT = new ICClass(-1, name, superclass, fields, methods);
	:}
	;

/* a list for both methods and fields */
fields_methods_list ::= method:m
	{:
		RESULT = new ArrayList<ASTNode>();
		RESULT.add(m);
	:}
	| fields_methods_list:lst method:m
	{:
		lst.add(m);
		RESULT = lst;
	:}
	| field_collection:field_col
	{:
		RESULT = new ArrayList<ASTNode>();
		for(Field field : field_col)
		{
			RESULT.add(field);
		}
	:}
	| fields_methods_list:lst field_collection:field_col
	{:
		RESULT = lst;
		for(Field field: field_col)
		{
			lst.add(field);
		}
	:}
	
	;
	
/* field_collection is an inline list of fields: DataType a, b, c... */
field_collection ::= type:t ID:name  field_id_list:lst SEMCOL
	{:
		RESULT = new ArrayList<Field>();
		
		// add the first field
		RESULT.add(new Field(t, name));     
		
		// add the rest of the fields (same type)
		for(String n : lst)
		{
			RESULT.add(new Field(t, n));
		}
	:}
	| type:t ID:name SEMCOL
	{:
		RESULT = new ArrayList<Field>();
		RESULT.add(new Field(t, name));
	:}
	;
	
/* represents a comma seperated id list, that appears (optionally) in a field */
field_id_list ::= COMMA ID:id
	{: RESULT = new ArrayList<String>();
	   RESULT.add(id); :}
	| field_id_list:lst COMMA ID:id
	{: RESULT = lst; RESULT.add(id); :}
	;

/* optional extends that appears in a class definition */
extends_opt ::= empty
	{: RESULT = null; :}
	| EXTENDS CLASSID:id
	{: RESULT = id; :}
	;

/* represents types */
type ::= INT
	{: RESULT = new PrimitiveType( -1, DataTypes.INT); :}
	| BOOL
	{: RESULT = new PrimitiveType( -1, DataTypes.BOOLEAN); :}
	| STRING
	{: RESULT = new PrimitiveType( -1, DataTypes.STRING); :}
	| CLASSID:id
	{: RESULT = new UserType( -1, id); :}
	| type:t SQUARELB SQUARERB
	{: RESULT = t; RESULT.incrementDimension(); :}
	;

/* method return type, can be void or type */	
return_type ::= type:t 
	{: RESULT = t; :}
	| VOID
	{: RESULT = new PrimitiveType(-1, DataTypes.VOID); :}
	;


/* handles deriving both virtual and static methods */	
method ::= STATIC return_type:t ID:name LP formal_list_opt:formals RP CLP stmt_lst:stmts CRP
	{:
		/* static method with statement list*/
		RESULT = new StaticMethod(t, name, formals, stmts);
		
	:}
	|
	type:t ID:name LP formal_list_opt:formals RP CLP stmt_lst:stmts CRP
	{:
		/* virtual method, non void, method with statement list */
			RESULT = new VirtualMethod(t, name, formals, stmts);
	:}
	|
	VOID ID:name LP formal_list_opt:formals RP CLP stmt_lst:stmts CRP
	{:
		/* void virtual method with statement list */
			RESULT = new VirtualMethod(new PrimitiveType(-1, DataTypes.VOID), name, formals, stmts);
	:}
	|
	type:t ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* non void virtual method without statement list */
		RESULT = new VirtualMethod(t, name, formals, new ArrayList<Statement>());
	:}
	|
	VOID ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* void virtual method without statement list */
		RESULT = new VirtualMethod(new PrimitiveType(-1, DataTypes.VOID), name, formals, new ArrayList<Statement>());
	:}
	|
	STATIC return_type:t ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* static method without statement list */
		RESULT = new StaticMethod(t, name, formals, new ArrayList<Statement>());
		
	:}
;

formal ::= type:t ID:name
	{: RESULT = new Formal(t, name); :}
	;

/* formals seperated by commas, used in formal list */
comma_formal_list ::= COMMA formal:f
	{: RESULT = new ArrayList<Formal>(); RESULT.add(f); :}
	| comma_formal_list:lst COMMA formal:f
	{: lst.add(f); RESULT = lst; :}
	;

/* represents formal list (non empty) */
formal_list ::= formal:f comma_formal_list:lst
	{: RESULT = new ArrayList<Formal>();
	   RESULT.add(f);
	   for(Formal formal : lst)
	   {
	   		RESULT.add(formal);
	   }
	:}
	| formal:f
	{: RESULT =  new ArrayList<Formal>(); RESULT.add(f); :}
	
	;
/* optional formal list, used in method definition */
formal_list_opt ::= formal_list:lst
	{: RESULT = lst; :}
	| empty
	{: RESULT = new ArrayList<Formal>(); :}
	;
	
	
	
	

binop ::= 	ADD
{: RESULT = BinaryOps.PLUS; :}
|  MINUS
{: RESULT = BinaryOps.MINUS; :}
|   MULT
{: RESULT = BinaryOps.MULTIPLY; :}
|   DIV
{: RESULT = BinaryOps.DIVIDE; :}
|   MOD
{: RESULT = BinaryOps.MOD; :}
|   LESSTHAN
{: RESULT = BinaryOps.LT; :}
|   LESSTHANEQ
{: RESULT = BinaryOps.LTE; :}
|  GREATERTHAN
{: RESULT = BinaryOps.GT; :}
|   GREATERTHANEQ
{: RESULT = BinaryOps.GTE; :}
|  EQ
{: RESULT = BinaryOps.EQUAL; :}
|  NOTEQ
{: RESULT = BinaryOps.NEQUAL; :}
|  AND
{: RESULT = BinaryOps.LAND; :}
|  OR
{: RESULT = BinaryOps.LOR; :}
;

unop ::=   MINUS
{: RESULT = UnaryOps.UMINUS; :}  
|  NOT  
{: RESULT = UnaryOps.LNEG; :}  
;

literal ::=  INTEGER
{: RESULT = LiteralType.INTEGER; :}
| STRING
{: RESULT = LiteralType.STRING; :}
| FALSE
{: RESULT = LiteralType.FALSE; :}
| NULL
{: RESULT = LiteralType.NULL; :}
| TRUE
{: RESULT = LiteralType.TRUE; :}
;

		

expr ::= location : loc
	{: RESULT = loc; :}

		| call: call_exp
	{: RESULT = call_exp; :}
		| THIS
	{: RESULT = new This(getLine()); :}
	   |  CLASSID:class_name LP RP
	{: RESULT = new NewClass(getLine(), class_name); :}
	   | type:type_type SQUARELB expr:exp  SQUARERB
	{: RESULT = new NewArray(type_type, exp); :}
	   |  expr:exp DOT  LENGTH
	{: RESULT = null; :} /*fix meeeee */

        |    expr:exp_1  binop:binop_op  expr:exp_2 SEMCOL /*fix me - ambuguity? */
	{:RESULT   :}
		| SEMCOL unop:unop_op expr:exp   SEMCOL   /*fix me - ambuguity? */
	{: RESULT = 	new UnaryOp(unop_op, exp); :} 
		| literal:l SEMCOL  /*fix me - ambuguity? */
	{: return l; :}
		| SEMCOL LP expr:exp RP SEMCOL SEMCOL   /*fix me - ambuguity? */
	{: return new ExpressionBlock(exp); :}
	;
	
	

/*
	stmt ::= location : loc EQ expr:exp SEMCOL
	{: RESULT = NEW Assignment(loc, exp); :}
	;
	
*/
	
stmt ::= location : loc EQ expr:exp SEMCOL
	{: RESULT = NEW Assignment(loc, exp); :}
		| call: call_exp SEMCOL
	{: RESULT = new CallStatement(call_exp); :}
		| RETURN  expr:exp  SEMCOL
	{: RESULT = new Return(getLine(), exp); :}
	   | IF LP expr:exp RP stmt: st1  ELSE stmt:st2 
	{: RESULT = new If(exp, st1, st2); :}
	   | WHILE LP expr:exp RP stmt:st
	{: RESULT = new While(exp , st ); :}
	   |  BREAK SEMCOL
	{: RESULT = new Break(getLine()) :}
	   |   CONTINUE SEMCOL
	{: RESULT =  new Continue(getLIne());  :}


		|  type: t ID: id EQ expr:exp SEMCOL
	{: RESULT =  new Assignment( id , exp); :}
			|  type: t ID: id  SEMCOL
	{: RESULT =   LocalVariable(t,id); :}
				| SQUARELB stmt_lst: st  SQUARERB SEMCOL  
	{: RESULT = new StatementsBlock(getLine(), st); :} 
	;
	
	/* UNTIL GT FIXED */
	stmt_lst ::= expr
	{: RESULT = null; :}
	;
	
	/*
stmt_lst ::= stmt_lst_not_empty:lst
	{: RESULT = lst :}
	| empty 
	{: RESULT = new ArrayList<Statement>():}
;

stmt_lst_not_empty ::= stmt :s
{: RESULT = new ArrayList<Statement>();
   RESULT.add(s);
:}
|   stmt_lst: st_lst stmt:s
{: st_lst.add(s);
   RESULT = st_list; :}
;


*/
	