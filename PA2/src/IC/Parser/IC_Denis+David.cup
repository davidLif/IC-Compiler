package IC.Parser;

import IC.AST.*;
import java.util.ArrayList;
import java.util.List;
import IC.LiteralTypes;
import IC.DataTypes;

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

/* ids */
terminal String ID;
terminal String CLASSID;
/* keywords */
terminal EXTENDS, STATIC, VOID, INT, BOOL, STRING, RETURN, IF, ELSE, WHILE, BREAK, CONTINUE;
terminal THIS, NEW, LENGTH, CLASS;
/* literals */
terminal Integer INTEGER;
terminal String STRING_LITERAL;
terminal FALSE, NULL, TRUE;
/* punctuation */
terminal LP, RP, CRP, CLP, SQUARERB, SQUARELB, DOT, SEMCOL, COMMA;
/* operators */
terminal ADD, MINUS, MULT, DIV, MOD, LESSTHAN, LESSTHANEQ, GREATERTHAN, GREATERTHANEQ, EQ;
terminal NOTEQ, AND, OR, NOT, ASSIGN;

nonterminal Program program;
nonterminal List<ICClass> class_list;
nonterminal ICClass       icclass;
nonterminal Method        method;

nonterminal String  extends_opt;
nonterminal List<ASTNode> fields_methods_list;

nonterminal Type type;
nonterminal List<Field> field_collection;
nonterminal List<String>    field_id_list;

nonterminal Type     return_type;

nonterminal Formal   formal;
nonterminal List<Formal> comma_formal_list;
nonterminal List<Formal> formal_list;
nonterminal List<Formal> formal_list_opt;

nonterminal List<Statement> stmt_list;
nonterminal Statement statement;
nonterminal List<Statement> stmt_list_opt;


nonterminal Call call;
nonterminal VirtualCall virtual_call;
nonterminal StaticCall static_call;
nonterminal Expression exp;
nonterminal Location location;
nonterminal ArrayLocation array_location;
nonterminal VariableLocation variable_location;
nonterminal Expression exp_and_dot_op;
nonterminal List<Expression> exp_list;
nonterminal Test_start;
nonterminal empty;
nonterminal List<Expression> exp_list_op;

//////////////////////////
// Precedence declarations

//////////////
// The grammar

Test_start ::= program {: :};

call ::= virtual_call:c {: RESULT =c; :}
		| static_call:c {: RESULT =c; :}
		;

static_call ::= CLASSID:class_id DOT ID:id LP exp_list_op:lst RP 
			{: RESULT = new StaticCall(1,class_id,id,lst); :}
			;
			
virtual_call ::= exp:e DOT ID:id LP exp_list_op:lst RP 
			{: RESULT = new VirtualCall(1,e,id,lst);:}
			| ID:id LP exp_list_op:lst RP 
			{: RESULT = new VirtualCall(1,new Literal(-1,LiteralTypes.STRING),id,lst);:}
			;

empty ::=	{: :};		
			
exp_list_op ::= exp_list:lst {: :} | empty {: RESULT = new ArrayList<Expression>(); :};

exp_list ::= exp:e 
			{:  List<Expression> lst = new ArrayList<Expression>();
				lst.add(e);
				RESULT = lst; :}
			| exp_list:lst exp:e 
			{:  lst.add(e);
				RESULT = lst; :}
			;


location ::= variable_location:loc {: RESULT =loc; :}
			| array_location:loc {: RESULT =loc; :}
			;
			
variable_location ::= ID:id {: RESULT = new VariableLocation(1,id); :}
					| exp:e DOT ID:id {: RESULT = new VariableLocation(1,e,id); :}
					;

array_location ::= exp:out_exp SQUARELB exp:in_exp SQUARERB
				{: RESULT = new ArrayLocation(out_exp,in_exp); :}
				;
			
/*FOR TESTING ONLY*/
exp ::= INTEGER {: RESULT = new Literal(1,LiteralTypes.STRING); :}
	;
	
	
	
	
	
	
program ::= class_list:lst
	{: RESULT = new Program(lst); :}
	| empty
	{: RESULT = new Program(new ArrayList<ICClass>()); :}
	;

class_list ::= icclass:c
	{: RESULT = new ArrayList<ICClass>();
	   RESULT.add(c); 
	:}
	| class_list:lst icclass:c
	{: lst.add(c); RESULT = lst; :}
	;

icclass ::= CLASS CLASSID:name extends_opt:superclass CLP fields_methods_list:lst CRP
	{: /* with a given method\field list */
		List<Field> fields = new ArrayList<Field>();
		List<Method> methods = new ArrayList<Method>();
		for(ASTNode item : lst)
		{
			if(item instanceof Field)
				fields.add((Field)item);
			else
				methods.add((Method)item);
		}
		if(superclass == null)
			RESULT = new ICClass( -1, name, fields, methods);
		else
			RESULT = new ICClass(-1, name, superclass, fields, methods);
		
	:}
	| CLASS CLASSID:name extends_opt:superclass CLP CRP
	{:  /* empty class */
		List<Field> fields = new ArrayList<Field>();
		List<Method> methods = new ArrayList<Method>();
		if(superclass == null)
			RESULT = new ICClass( -1, name, fields, methods);
		else
			RESULT = new ICClass(-1, name, superclass, fields, methods);
	:}
	;

/* a list for both methods and fields */
fields_methods_list ::= method:m
	{:
		RESULT = new ArrayList<ASTNode>();
		RESULT.add(m);
	:}
	| fields_methods_list:lst method:m
	{:
		lst.add(m);
		RESULT = lst;
	:}
	| field_collection:field_col
	{:
		RESULT = new ArrayList<ASTNode>();
		for(Field field : field_col)
		{
			RESULT.add(field);
		}
	:}
	| fields_methods_list:lst field_collection:field_col
	{:
		RESULT = lst;
		for(Field field: field_col)
		{
			lst.add(field);
		}
	:}
	
	;
	
/* field_collection is an inline list of fields: DataType a, b, c... */
field_collection ::= type:t ID:name  field_id_list:lst SEMCOL
	{:
		RESULT = new ArrayList<Field>();
		
		// add the first field
		RESULT.add(new Field(t, name));     
		
		// add the rest of the fields (same type)
		for(String n : lst)
		{
			RESULT.add(new Field(t, n));
		}
	:}
	| type:t ID:name SEMCOL
	{:
		RESULT = new ArrayList<Field>();
		RESULT.add(new Field(t, name));
	:}
	;
	
/* represents a comma seperated id list, that appears (optionally) in a field */
field_id_list ::= COMMA ID:id
	{: RESULT = new ArrayList<String>();
	   RESULT.add(id); :}
	| field_id_list:lst COMMA ID:id
	{: RESULT = lst; RESULT.add(id); :}
	;

/* optional extends that appears in a class definition */
extends_opt ::= empty
	{: RESULT = null; :}
	| EXTENDS CLASSID:id
	{: RESULT = id; :}
	;

/* represents types */
type ::= INT
	{: RESULT = new PrimitiveType( -1, DataTypes.INT); :}
	| BOOL
	{: RESULT = new PrimitiveType( -1, DataTypes.BOOLEAN); :}
	| STRING
	{: RESULT = new PrimitiveType( -1, DataTypes.STRING); :}
	| CLASSID:id
	{: RESULT = new UserType( -1, id); :}
	| type:t SQUARELB SQUARERB
	{: RESULT = t; RESULT.incrementDimension(); :}
	;

/* method return type, can be void or type */	
return_type ::= type:t 
	{: RESULT = t; :}
	| VOID
	{: RESULT = new PrimitiveType(-1, DataTypes.VOID); :}
	;


/* handles deriving both virtual and static methods */	
method ::= STATIC return_type:t ID:name LP formal_list_opt:formals RP CLP stmt_list:stmts CRP
	{:
		/* static method with statement list*/
		RESULT = new StaticMethod(t, name, formals, stmts);
		
	:}
	|
	type:t ID:name LP formal_list_opt:formals RP CLP stmt_list:stmts CRP
	{:
		/* virtual method, non void, method with statement list */
			RESULT = new VirtualMethod(t, name, formals, stmts);
	:}
	|
	VOID ID:name LP formal_list_opt:formals RP CLP stmt_list:stmts CRP
	{:
		/* void virtual method with statement list */
			RESULT = new VirtualMethod(new PrimitiveType(-1, DataTypes.VOID), name, formals, stmts);
	:}
	|
	type:t ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* non void virtual method without statement list */
		RESULT = new VirtualMethod(t, name, formals, new ArrayList<Statement>());
	:}
	|
	VOID ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* void virtual method without statement list */
		RESULT = new VirtualMethod(new PrimitiveType(-1, DataTypes.VOID), name, formals, new ArrayList<Statement>());
	:}
	|
	STATIC return_type:t ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* static method without statement list */
		RESULT = new StaticMethod(t, name, formals, new ArrayList<Statement>());
		
	:}
;

formal ::= type:t ID:name
	{: RESULT = new Formal(t, name); :}
	;

/* formals seperated by commas, used in formal list */
comma_formal_list ::= COMMA formal:f
	{: RESULT = new ArrayList<Formal>(); RESULT.add(f); :}
	| comma_formal_list:lst COMMA formal:f
	{: lst.add(f); RESULT = lst; :}
	;

/* represents formal list (non empty) */
formal_list ::= formal:f comma_formal_list:lst
	{: RESULT = new ArrayList<Formal>();
	   RESULT.add(f);
	   for(Formal formal : lst)
	   {
	   		RESULT.add(formal);
	   }
	:}
	| formal:f
	{: RESULT =  new ArrayList<Formal>(); RESULT.add(f); :}
	
	;
/* optional formal list, used in method definition */
formal_list_opt ::= formal_list:lst
	{: RESULT = lst; :}
	| empty
	{: RESULT = new ArrayList<Formal>(); :}
	;

/* statement list, non empty */
stmt_list ::= statement:stmt
	{: RESULT = new ArrayList<Statement>(); RESULT.add(stmt); :}
	| stmt_list:lst statement:stmt
	{: lst.add(stmt); RESULT = lst; :}
	
	;

stmt_list_opt ::= empty
	{: RESULT = new ArrayList<Statement>(); :}
	| stmt_list:lst
	{: RESULT = lst; :}
	;
	
statement ::= BREAK SEMCOL
	{:
		RESULT = new Break(-1);
	:}
	/*| call:c SEMCOL 
	{:
		RESULT = new CallStatement(c);
	:}*/
	| location:loc EQ exp:e SEMCOL
	{:
		RESULT = new Assignment(loc,e);
	:}
	;