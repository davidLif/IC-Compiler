package IC.Parser;

import IC.AST.*;

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

/* ids */
terminal String ID, CLASSID;
/* keywords */
terminal EXTENDS, STATIC, VOID, INT, BOOL, STRING, RETURN, IF, ELSE, WHILE, BREAK, CONTINUE;
terminal THIS, NEW, LENGTH, CLASS;
/* literals */
terminal INTEGER, STRING_LITERAL, FALSE, NULL, TRUE;
/* punctuation */
terminal LP, RP, CRP, CLP, SQUARERB, SQUARELB, DOT, SEMCOL, COMMA;
/* operators */
terminal ADD, MINUS, MULT, DIV, MOD, LESSTHAN, LESSTHANEQ, GREATERTHAN, GREATERTHANEQ, EQ;
terminal NOTEQ, AND, OR, NOT, ASSIGN;


nonterminal Program Program;
nonterminal Literal;


//////////////////////////
// Precedence declarations

//////////////
// The grammar

nonterminal String extends_opt


Program ::= class_list:lst
	{: RESULT = new Program(lst); :}
class_list ::= class:c
{: RESULT = new ArrayList<Icclass>();
   RESULT.add(c);
:}
|   class_list: lst class:c
{: lst.add(c);
   RESULT = lst; :}
}
| 
{: RESULT = null; :}



class ::= CLASS CLASSID:name extends_opt:extends_name CLP fields_methods_list:lst  CRP
{ :
	List<Field> fieldlst = new Arraylist<Field>();
	List<Method> methodlst = new Arraylist<Method>();
	for( item:lst)
	{
		if ( item instanceof(Field))
		{
			fieldlst.add(item);
		}
			else
			{
				methodlst.add(item);				
			}
		
		
	}
	RESULT = new ICClass(getLine(),name,field)
	
	
	
	
fields_methods_list ::= method:m
{: RESULT = new ArrayList<ASTNode>();
	RESULT.add(m); :}
| field : f
{: RESULT = new ArrayList<ASTNode>();
RESULT.add(f); :}
| fields_methods_list:lst method:m
{: lst.add(m);
	RESULT:lst; :}
| fields_methods_list:lst field:f
{: lst.add(f);
	RESULT:lst; :}
| 
{: RESULT = null; :}
	



extends_opt ::= EXTENDS CLASSID : id
	{: RESULT = id; :}
	| 
	{: RESULT = null; :} 
	
	
	
	
	
stmt ::= location : loc EQ expression:exp SEMCOL
	{: RESULT = NEW Assignment(loc, exp); :}
		| call: call_exp SEMCOL
	{: RESULT = new CallStatement(call_exp); :}
		| RETURN  expression:exp  SEMCOL
	{: RESULT = new Return(getLine(), exp); :}
	   | IF LB expression:exp RB stmt: st1  ELSE stmt:st2 
	{: RESULT = new If(exp, st1, st2); :}
	   | WHILE LB expression:exp RB stmt:st
	{: RESULT = new While(exp , st ); :}
	   |  BREAK SEMCOL
	{: RESULT = new Break(getLine()) :}
        |   CONTINUE SEMCOL
	{: RESULT =  new Continue(getLIne());  :}
		| SQUARELB stmt:st SQUARERN SEMCOL  // FIXXXXXXX
	{: RESULT = 	new UnaryOp(unop_op, exp); :} 
		| SQUARELB stmt_star: st  SQUARERN SEMCOL  
	{: RESULT = new StatementsBlock(getLine(), st); :} 
		|  type: t ID: id EQ expression:exp SEMCOL
	{: return  new Assignment( id , exp :}

stmt_star ::= stmt_list:lst
	{: RESULT = new Program(lst); :}
	
stmt_list ::= stmt :s
{: RESULT = new ArrayList<Statement>();
   RESULT.add(s);
:}
|   stmt_list: st_list stmt:s
{: st_list.add(s);
   RESULT = st_list:}
}
| 
{: RESULT = null; :}



	
	
	
expression ::= location : loc
	{: RESULT = loc; :}
		| call: call_exp
	{: RESULT = call_exp; :}
		| this
	{: RESULT = new This(getLine()); :}
	   |  CLASSID:class_name LB RB
	{: RESULT = new NewClass(getLine(), class_name); :}
	   | type:type_type SQUARELB expression:exp SQUARERN
	{: RESULT = new NewArray(type_type, exp); :}
	   |  expression:exp DOT  LENGTH
	{: RESULT = loc; :}
        |    expression:exp_1 binop:binop_op  expression:exp_2
	{: RESULT = new BinaryOp(exp_1, binop_op, exp_2);  :}
		| unop:unop_op expression:exp
	{: RESULT = 	new UnaryOp(unop_op, exp); :} 
		| literal: l
	{: return l; :}
		|  LB expression:exp RB
	{: return new ExpressionBlock(exp); :}
	
binop ::= 	ADD
{: RESULT = BinaryOps.PLUS; :}
|  MINUS
{: RESULT = BinaryOps.MINUS; :}
|   MULT
{: RESULT = BinaryOps.MULTIPLY; :}
|   DIV
{: RESULT = BinaryOps.DIVIDE; :}
|   MOD
{: RESULT = BinaryOps.MOD; :}
|   LESSTHAN
{: RESULT = BinaryOps.LT; :}
|   LESSTHANEQ
{: RESULT = BinaryOps.LTE; :}
|  GREATERTHAN
{: RESULT = BinaryOps.GT; :}
|   GREATERTHANEQ
{: RESULT = BinaryOps.GTE; :}
|  EQ
{: RESULT = BinaryOps.EQUAL; :}
|
{: RESULT = BinaryOps.NEQUAL; :}
|



unop ::=   MINUS
{: RESULT = UnaryOps.UMINUS; :}  
|  NOT  
{: RESULT = UnaryOps.LNEG; :}  

terminal INTEGER, STRING_LITERAL, FALSE, NULL, TRUE;


literal ::=  INTEGER
{: RESULT = LiteralType.INTEGER; :}
| STRING
{: RESULT = LiteralType.STRING; :}
| FALSE
{: RESULT = LiteralType.FALSE; :}
| NULL
{: RESULT = LiteralType.NULL; :}
| TRUE
{: RESULT = LiteralType.TRUE; :}




