package IC.Parser;

import IC.AST.*;
import java.util.ArrayList;
import java.util.List;
import IC.LiteralTypes;
import IC.DataTypes;
import IC.BinaryOps;
import IC.UnaryOps;
import java_cup.runtime.Symbol;
import IC.LiteralTypes;


parser code {:

	private SyntaxError err;

	public void syntax_error(Symbol cur_token) {

		expected_token_ids();
		List<Integer> lst_tokens = expected_token_ids();
		err =  new SyntaxError((Token)cur_token, lst_tokens);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws SyntaxError
	{
		throw err;
	}
	
	public int getLine()
	{
		return 0;
	}

:}


////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

/* ids */
terminal String ID;
terminal String CLASSID;
/* keywords */
terminal EXTENDS, STATIC, VOID, INT, BOOL, STRING, RETURN, IF, ELSE, WHILE, BREAK, CONTINUE;
terminal THIS, NEW, LENGTH, CLASS;
/* literals */
terminal Integer INTEGER;
terminal String STRING_LITERAL;
terminal FALSE, NULL, TRUE;
/* punctuation */
terminal LP, RP, CRP, CLP, SQUARERB, SQUARELB, DOT, SEMCOL, COMMA;
/* operators */
terminal ADD, MINUS, MULT, DIV, MOD, LESSTHAN, LESSTHANEQ, GREATERTHAN, GREATERTHANEQ, EQ;
terminal NOTEQ, AND, OR, NOT, ASSIGN;

terminal UMINUS, ARR_ACCESS, METHOD_CALL;

nonterminal Program program;
nonterminal List<ICClass> class_list;
nonterminal ICClass       icclass;
nonterminal Method        method;

nonterminal String  extends_opt;
nonterminal List<ASTNode> fields_methods_list;

nonterminal Type type;
nonterminal List<Field> field_collection;
nonterminal List<String>    field_id_list;

nonterminal Type     return_type;

nonterminal Formal   formal;
nonterminal List<Formal> comma_formal_list;
nonterminal List<Formal> formal_list;
nonterminal List<Formal> formal_list_opt;

nonterminal List<Statement> stmt_lst;


//

nonterminal Statement stmt;
nonterminal Expression expr;
//nonterminal BinaryOps binop;
//nonterminal UnaryOp unop;
nonterminal Literal literal;
nonterminal Location location;
nonterminal Call call;

nonterminal List<Expression> exp_list;
nonterminal List<Expression> exp_comma_list;
nonterminal VirtualCall virtual_call;
nonterminal StaticCall static_call;

nonterminal empty; /* epsilon derivation */




//////////////////////////
// Precedence declarations
precedence right ELSE;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence left EQ, NOTEQ;
precedence left LESSTHAN, LESSTHANEQ, GREATERTHAN, GREATERTHANEQ;
precedence left ADD, MINUS;
precedence left MULT, DIV, MOD;
precedence right UMINUS, NOT;
precedence left DOT, ARR_ACCESS, METHOD_CALL;





//////////////
// The grammar


program ::= class_list:lst
	{: RESULT = new Program(lst); :}
	| empty
	{: RESULT = new Program(new ArrayList<ICClass>()); :}
;

	

class_list ::= icclass:c
	{: RESULT = new ArrayList<ICClass>();
	   RESULT.add(c); 
	:}
	| class_list:lst icclass:c
	{: lst.add(c); RESULT = lst; :}
	;

icclass ::= CLASS CLASSID:name extends_opt:superclass CLP fields_methods_list:lst CRP
	{: /* with a given method\field list */
		List<Field> fields = new ArrayList<Field>();
		List<Method> methods = new ArrayList<Method>();
		for(ASTNode item : lst)
		{
			if(item instanceof Field)
				fields.add((Field)item);
			else
				methods.add((Method)item);
		}
		if(superclass == null)
			RESULT = new ICClass( -1, name, fields, methods);
		else
			RESULT = new ICClass(-1, name, superclass, fields, methods);
		
	:}
	| CLASS CLASSID:name extends_opt:superclass CLP CRP
	{:  /* empty class */
		List<Field> fields = new ArrayList<Field>();
		List<Method> methods = new ArrayList<Method>();
		if(superclass == null)
			RESULT = new ICClass( -1, name, fields, methods);
		else
			RESULT = new ICClass(-1, name, superclass, fields, methods);
	:}
	;

/* a list for both methods and fields */
fields_methods_list ::= method:m
	{:
		RESULT = new ArrayList<ASTNode>();
		RESULT.add(m);
	:}
	| fields_methods_list:lst method:m
	{:
		lst.add(m);
		RESULT = lst;
	:}
	| field_collection:field_col
	{:
		RESULT = new ArrayList<ASTNode>();
		for(Field field : field_col)
		{
			RESULT.add(field);
		}
	:}
	| fields_methods_list:lst field_collection:field_col
	{:
		RESULT = lst;
		for(Field field: field_col)
		{
			lst.add(field);
		}
	:}
	
	;
	
/* field_collection is an inline list of fields: DataType a, b, c... */
field_collection ::= type:t ID:name  field_id_list:lst SEMCOL
	{:
		RESULT = new ArrayList<Field>();
		
		// add the first field
		RESULT.add(new Field(t, name));     
		
		// add the rest of the fields (same type)
		for(String n : lst)
		{
			RESULT.add(new Field(t, n));
		}
	:}
	| type:t ID:name SEMCOL
	{:
		RESULT = new ArrayList<Field>();
		RESULT.add(new Field(t, name));
	:}
	;
	
/* represents a comma seperated id list, that appears (optionally) in a field */
field_id_list ::= COMMA ID:name
	{: RESULT = new ArrayList<String>();
	   RESULT.add(name); :}
	| field_id_list:lst COMMA ID:name
	{: RESULT = lst; RESULT.add(name); :}
	;

/* optional extends that appears in a class definition */
extends_opt ::= empty
	{: RESULT = null; :}
	| EXTENDS CLASSID:name
	{: RESULT = name; :}
	;

/* represents types */
type ::= INT
	{: RESULT = new PrimitiveType( -1, DataTypes.INT); :}
	| BOOL
	{: RESULT = new PrimitiveType( -1, DataTypes.BOOLEAN); :}
	| STRING
	{: RESULT = new PrimitiveType( -1, DataTypes.STRING); :}
	| CLASSID:name
	{: RESULT = new UserType( -1, name); :}
	| type:t SQUARELB SQUARERB
	{: RESULT = t; RESULT.incrementDimension(); :}
	;

/* method return type, can be void or type */	
return_type ::= type:t 
	{: RESULT = t; :}
	| VOID
	{: RESULT = new PrimitiveType(-1, DataTypes.VOID); :}
	;


/* handles deriving both virtual and static methods */	
method ::= STATIC return_type:t ID:name LP formal_list_opt:formals RP CLP stmt_lst:stmts CRP
	{:
		/* static method with statement list*/
		RESULT = new StaticMethod(t, name, formals, stmts);
		
	:}
	|
	type:t ID:name LP formal_list_opt:formals RP CLP stmt_lst:stmts CRP
	{:
		/* virtual method, non void, method with statement list */
			RESULT = new VirtualMethod(t, name, formals, stmts);
	:}
	|
	VOID ID:name LP formal_list_opt:formals RP CLP stmt_lst:stmts CRP
	{:
		/* void virtual method with statement list */
			RESULT = new VirtualMethod(new PrimitiveType(-1, DataTypes.VOID), name, formals, stmts);
	:}
	|
	type:t ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* non void virtual method without statement list */
		RESULT = new VirtualMethod(t, name, formals, new ArrayList<Statement>());
	:}
	|
	VOID ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* void virtual method without statement list */
		RESULT = new VirtualMethod(new PrimitiveType(-1, DataTypes.VOID), name, formals, new ArrayList<Statement>());
	:}
	|
	STATIC return_type:t ID:name LP formal_list_opt:formals RP CLP CRP
	{:
		/* static method without statement list */
		RESULT = new StaticMethod(t, name, formals, new ArrayList<Statement>());
		
	:}
;

formal ::= type:t ID:name
	{: RESULT = new Formal(t, name); :}
	;

/* formals seperated by commas, used in formal list */
comma_formal_list ::= COMMA formal:f
	{: RESULT = new ArrayList<Formal>(); RESULT.add(f); :}
	| comma_formal_list:lst COMMA formal:f
	{: lst.add(f); RESULT = lst; :}
	;

/* represents formal list (non empty) */
formal_list ::= formal:f comma_formal_list:lst
	{: RESULT = new ArrayList<Formal>();
	   RESULT.add(f);
	   for(Formal formal : lst)
	   {
	   		RESULT.add(formal);
	   }
	:}
	| formal:f
	{: RESULT =  new ArrayList<Formal>(); RESULT.add(f); :}
	
	;
/* optional formal list, used in method definition */
formal_list_opt ::= formal_list:lst
	{: RESULT = lst; :}
	| empty
	{: RESULT = new ArrayList<Formal>(); :}
	;
	
	
/* statement list, non empty */
stmt_lst ::= stmt:s
	{: RESULT = new ArrayList<Statement>(); RESULT.add(s); :}
	| stmt_lst:lst stmt:s
	{: lst.add(s); RESULT = lst; :}
	
	;

stmt ::= location:loc ASSIGN expr:exp SEMCOL
	{: RESULT = new Assignment(loc, exp); :}
	| call:c SEMCOL
	{: RESULT = new CallStatement(c); :}
	| RETURN  expr:exp  SEMCOL
	{: RESULT = new Return(getLine(), exp); :}
	| RETURN SEMCOL
	{: RESULT = new Return(getLine()); :}
	| IF LP expr:exp RP stmt:st1  ELSE stmt:st2  /* with else */
	{: RESULT = new If(exp, st1, st2); :}
	| IF LP expr:exp RP stmt:st   /* without else */
	{: RESULT = new If(exp,st); :}
	| WHILE LP expr:exp RP stmt:st
	{: RESULT = new While(exp , st); :}
	|  BREAK SEMCOL
	{: RESULT = new Break(getLine()); :}
	|  CONTINUE SEMCOL
	{: RESULT =  new Continue(getLine());  :}
	/* statement block with list */
	| CLP stmt_lst:statements CRP
	{: RESULT = new StatementsBlock(getLine(),statements); :}
	/* statement block without list */
	| CLP CRP 
	{: RESULT = new StatementsBlock(getLine(), new ArrayList<Statement>()); :}
	/* local variable */
	 | type:t ID:name SEMCOL
	 {: RESULT = new LocalVariable(t, name); :}
	 | type:t ID:name ASSIGN expr:exp SEMCOL
	 {: RESULT = new LocalVariable(t, name, exp); :}
;
/* -------------------- */

 // binop ::= 	ADD
 // {: RESULT = BinaryOps.PLUS; :}
 // |  MINUS
 // {: RESULT = BinaryOps.MINUS; :}
 // |   MULT
 // {: RESULT = BinaryOps.MULTIPLY; :}
 // |   DIV
 // {: RESULT = BinaryOps.DIVIDE; :}
 // |   MOD
 // {: RESULT = BinaryOps.MOD; :}
 // |   LESSTHAN
 // {: RESULT = BinaryOps.LT; :}
 // |   LESSTHANEQ
 // {: RESULT = BinaryOps.LTE; :}
 // |  GREATERTHAN
 // {: RESULT = BinaryOps.GT; :}
 // |  GREATERTHANEQ
 // {: RESULT = BinaryOps.GTE; :}
 // |  EQ
 // {: RESULT = BinaryOps.EQUAL; :}
 // |  NOTEQ
 // {: RESULT = BinaryOps.NEQUAL; :}
 // |  AND
 // {: RESULT = BinaryOps.LAND; :}
 // |  OR
 // {: RESULT = BinaryOps.LOR; :}
 // ;

 // unop ::=  MINUS
 // {: RESULT = UnaryOps.UMINUS; :}  
 // |  NOT  
 // {: RESULT = UnaryOps.LNEG; :}  
 // ;

 literal ::= INTEGER:val
 {: RESULT = new Literal(getLine(),LiteralTypes.INTEGER, val); :}
 | STRING_LITERAL:str 
 {: RESULT = new Literal(getLine(),LiteralTypes.STRING, str); :}
 | FALSE
 {: RESULT = new Literal(getLine(),LiteralTypes.FALSE); :}
 | NULL
 {: RESULT = new Literal(getLine(),LiteralTypes.NULL); :}
 | TRUE
 {: RESULT = new Literal(getLine(), LiteralTypes.TRUE); :}
 ;



expr ::= location:loc
	{: RESULT = loc; :}
	| call:call_exp
	{: RESULT = call_exp; :}
	| THIS
	{: RESULT = new This(getLine()); :}
	|  NEW CLASSID:class_name LP RP
	{: RESULT = new NewClass(getLine(), class_name); :}
	|  NEW type:t SQUARELB expr:exp  SQUARERB
	{: RESULT = new NewArray(t, exp); :}
	|  expr:exp DOT LENGTH
	{: RESULT = new Length(exp); :} 
	
	/* binary and unary operations */
	
    |  expr:exp_1  ADD  expr:exp_2
	{:
		
		RESULT = new MathBinaryOp(exp_1, BinaryOps.PLUS, exp_2);
	
	:}
	 |  expr:exp_1  MINUS  expr:exp_2
	{:
		
		RESULT = new MathBinaryOp(exp_1, BinaryOps.MINUS, exp_2);
	
	:}
	 |  expr:exp_1  MULT  expr:exp_2
	{:
		
		RESULT = new MathBinaryOp(exp_1, BinaryOps.MULTIPLY, exp_2);
	
	:}
	 |  expr:exp_1  DIV  expr:exp_2
	{:
		
		RESULT = new MathBinaryOp(exp_1, BinaryOps.DIVIDE, exp_2);
	
	:}
	 |  expr:exp_1  MOD  expr:exp_2
	{:
		
		RESULT = new MathBinaryOp(exp_1, BinaryOps.MOD, exp_2);
	
	:}
	 |  expr:exp_1  LESSTHAN  expr:exp_2
	{:
		
		RESULT = new LogicalBinaryOp(exp_1, BinaryOps.LT, exp_2);
	
	:}
	 |  expr:exp_1  LESSTHANEQ  expr:exp_2
	{:
		
		RESULT = new LogicalBinaryOp(exp_1, BinaryOps.LTE, exp_2);
	
	:}
	 |  expr:exp_1  GREATERTHAN  expr:exp_2
	{:
		
		RESULT = new LogicalBinaryOp(exp_1, BinaryOps.GT, exp_2);
	
	:}
	 |  expr:exp_1  GREATERTHANEQ  expr:exp_2
	{:
		
		RESULT = new LogicalBinaryOp(exp_1, BinaryOps.GTE, exp_2);
	
	:}
	 |  expr:exp_1  EQ  expr:exp_2
	{:
		
		RESULT = new LogicalBinaryOp(exp_1, BinaryOps.EQUAL, exp_2);
	
	:}
	 |  expr:exp_1  NOTEQ  expr:exp_2
	{:
		
		RESULT = new LogicalBinaryOp(exp_1, BinaryOps.NEQUAL, exp_2);
	
	:}
	 |  expr:exp_1  AND  expr:exp_2
	{:
		
		RESULT = new LogicalBinaryOp(exp_1, BinaryOps.LAND, exp_2);
	
	:}
	 |  expr:exp_1  OR  expr:exp_2
	{:
		
		RESULT = new LogicalBinaryOp(exp_1, BinaryOps.LOR, exp_2);
	
	:}
	
	
	|  MINUS expr:exp 
	{: 
		
			RESULT = new MathUnaryOp(UnaryOps.UMINUS, exp); 

	:}
	%prec UMINUS
	
	|  NOT expr:exp 
	{: 
		
			RESULT = new LogicalUnaryOp(UnaryOps.LNEG, exp); 

	:}
	
	| literal:l 
	{: 
		 RESULT = l;
	:}
	| LP expr:exp RP 
	{: RESULT = new ExpressionBlock(exp); :}
;
	


location ::= ID:name
	{: RESULT = new VariableLocation(getLine(), name); :}
    | expr:exp DOT ID:name
	{: RESULT = new VariableLocation(getLine(), exp, name); :}
	| expr:array SQUARELB expr:index SQUARERB
	{: RESULT = new ArrayLocation(array, index); :}
	%prec ARR_ACCESS
;
			
	
empty ::= 
	{: :}
;

static_call ::= CLASSID:class_name DOT ID:name LP RP 
			/* static call without expression list */
			{: RESULT = new StaticCall(1, class_name, name, new ArrayList<Expression>()); :}
			%prec METHOD_CALL
			| CLASSID:class_name DOT ID:name LP exp_list:lst RP
			/* static call WITH expression list */
			{: RESULT = new StaticCall(1, class_name, name, lst); :}
			%prec METHOD_CALL
;
			
virtual_call ::= expr:e DOT ID:name LP exp_list:lst RP 
			/* with location, with expression list */
			{: RESULT = new VirtualCall(1, e, name, lst); :}
			%prec METHOD_CALL
			| ID:name LP exp_list:lst RP 
			/* without location, with expression list */
			{: RESULT = new VirtualCall(1, null, name, lst); :}
			 %prec METHOD_CALL
			/* with location, without expression list */
			| expr:e DOT ID:name LP RP
			{: RESULT = new VirtualCall(1, e, name, new ArrayList<Expression>()); :}
			%prec METHOD_CALL
			/* without location, without expression list */
			| ID:name LP RP
			{: RESULT = new VirtualCall(1, null, name, new ArrayList<Expression>()); :}
			%prec METHOD_CALL
;



call ::= virtual_call:val
		{: RESULT = val; :}
		| static_call:val 
		{: RESULT = val; :}
;



/* represents expression list: expr (',' expr)* */
exp_list ::= expr:exp
		  {: RESULT = new ArrayList<Expression>(); RESULT.add(exp); :}
		  | expr:exp exp_comma_list:lst
		  {: 
			List<Expression> res = new ArrayList<Expression>();
			res.add(exp);
			for(Expression e:lst)
			{
				res.add(e);
			}
			RESULT = res;
		  :}
;
/* represents expression list seperated with commas (',' expr)+ [non empty] */
exp_comma_list ::= COMMA expr:exp
			{: RESULT = new ArrayList<Expression>(); RESULT.add(exp); :}
			| exp_comma_list:lst COMMA expr:exp
			{: lst.add(exp); RESULT = lst; :}
;


	