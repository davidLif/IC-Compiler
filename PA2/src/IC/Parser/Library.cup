package IC.Parser;

import IC.AST.*;
import java.util.ArrayList;
import java.util.List;
import IC.DataTypes;
import java_cup.runtime.Symbol;


parser code {:
public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+ ": Syntax error; unexpected " + tok);
	}
:}

/* ids */
terminal String ID;
terminal String CLASSID;
/* keywords */
terminal STATIC, VOID, BOOL, STRING;
terminal INT;
terminal CLASS;

/* punctuation */
terminal LP, RP, CRP, CLP, SQUARERB, SQUARELB, SEMCOL, COMMA;


nonterminal Program program;
nonterminal ICClass       lib_class;
nonterminal Method        method;
nonterminal List<Method>  method_list_opt;
nonterminal List<Method>  method_list;
nonterminal Type     type;
nonterminal Type     return_type;

nonterminal Formal   formal;
nonterminal List<Formal> comma_formal_list;
nonterminal List<Formal> formal_list;
nonterminal List<Formal> formal_list_opt;


nonterminal String library_name;


// epsilon
nonterminal empty;


//////////////
// The grammar

program ::= lib_class:c
	{: List<ICClass> classes = new ArrayList<ICClass>();
	   classes.add(c);
	   RESULT = new Program(classes);
	:}
;

lib_class ::= CLASS library_name:name CLP method_list_opt:lst CRP
	{:
		RESULT = new ICClass(-1, name, new ArrayList<Field>(), lst);
	:}
;

method_list_opt ::= empty
	{: RESULT = new ArrayList<Method>(); :}
	| method_list:lst
	{: RESULT = lst; :}
;

method_list ::= method:m
	{: RESULT = new ArrayList<Method>(); RESULT.add(m); :}
	| method_list:lst method:m
	{: lst.add(m); RESULT = lst; :}
;

library_name ::= CLASSID:id
	{:
		if(!id.equals("Library"))
		{
			// report error
		}
		RESULT = id;
	:}
;

method ::= STATIC return_type:t ID:name LP formal_list_opt:formals RP SEMCOL
	{:
		RESULT = new LibraryMethod(t, name, formals);
	:}
;

/* represents formal list (non empty) */
formal_list ::= formal:f comma_formal_list:lst
	{: RESULT = new ArrayList<Formal>();
	   RESULT.add(f);
	   for(Formal formal : lst)
	   {
	   		RESULT.add(formal);
	   }
	:}
	| formal:f
	{: RESULT =  new ArrayList<Formal>(); RESULT.add(f); :}
	
;

/* optional formal list, used in method definition */
formal_list_opt ::= formal_list:lst
	{: RESULT = lst; :}
	| empty
	{: RESULT = new ArrayList<Formal>(); :}
;

formal ::= type:t ID:name
	{: RESULT = new Formal(t, name); :}
;

/* formals seperated by commas, used in formal list */
comma_formal_list ::= COMMA formal:f
	{: RESULT = new ArrayList<Formal>(); RESULT.add(f); :}
	| comma_formal_list:lst COMMA formal:f
	{: lst.add(f); RESULT = lst; :}
;

/* method return type, can be void or type */	
return_type ::= type:t 
	{: RESULT = t; :}
	| VOID
	{: RESULT = new PrimitiveType(-1, DataTypes.VOID); :}
;

/* represents types */
type ::= INT
	{: RESULT = new PrimitiveType( -1, DataTypes.INT); :}
	| BOOL
	{: RESULT = new PrimitiveType( -1, DataTypes.BOOLEAN); :}
	| STRING
	{: RESULT = new PrimitiveType( -1, DataTypes.STRING); :}
	| CLASSID:id
	{: RESULT = new UserType( -1, id); :}
	| type:t SQUARELB SQUARERB
	{: RESULT = t; RESULT.incrementDimension(); :}
;


empty ::= 
	{: :}
;